import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import requests
import json
from datetime import datetime, timedelta
import threading
from itertools import product
import heapq
from PIL import Image, ImageTk
import io

class MapleSymbolOptimizer:
    def __init__(self, root):
        self.root = root
        self.root.title("메이플스토리 심볼 최적화 프로그램")
        self.root.geometry("1000x800")
        
        # 심볼 데이터 (문서에서 제공된 데이터)
        self.setup_symbol_data()
        
        # GUI 구성 요소들
        self.api_key = tk.StringVar()
        self.character_name = tk.StringVar()
        self.target_force = tk.IntVar()
        self.symbol_type = tk.StringVar(value="arcane")
        
        # 캐릭터 정보 저장
        self.character_info = {}
        self.symbol_info = {}
        
        self.setup_gui()
        
    def setup_symbol_data(self):
        """심볼 데이터 초기화 - 딕셔너리 자료구조 사용"""
        # 아케인 심볼 데이터
        self.arcane_symbols = {
            'vanishing_journey': {2: 97, 3: 123, 4: 166, 5: 226, 6: 306, 7: 404, 8: 522, 9: 660, 10: 818, 11: 999, 12: 1201, 13: 1426, 14: 1674, 15: 1945, 16: 2242, 17: 2563, 18: 2910, 19: 3283, 20: 3682},
            'chu_chu_island': {2: 121, 3: 153, 4: 206, 5: 280, 6: 378, 7: 498, 8: 642, 9: 810, 10: 1002, 11: 1221, 12: 1465, 13: 1736, 14: 2034, 15: 2359, 16: 2714, 17: 3097, 18: 3510, 19: 3953, 20: 4426},
            'lachelein': {2: 145, 3: 183, 4: 246, 5: 334, 6: 450, 7: 592, 8: 762, 9: 960, 10: 1186, 11: 1443, 12: 1729, 13: 2046, 14: 2394, 15: 2773, 16: 3186, 17: 3631, 18: 4110, 19: 4623, 20: 5170},
            'arcana': {2: 169, 3: 213, 4: 286, 5: 388, 6: 522, 7: 686, 8: 882, 9: 1110, 10: 1370, 11: 1665, 12: 1993, 13: 2356, 14: 2754, 15: 3187, 16: 3658, 17: 4165, 18: 4710, 19: 5293, 20: 5914},
            'morass': {2: 193, 3: 243, 4: 326, 5: 442, 6: 594, 7: 780, 8: 1002, 9: 1260, 10: 1554, 11: 1887, 12: 2257, 13: 2666, 14: 3114, 15: 3601, 16: 4130, 17: 4699, 18: 5310, 19: 5963, 20: 6658},
            'esfera': {2: 217, 3: 273, 4: 366, 5: 496, 6: 666, 7: 874, 8: 1122, 9: 1410, 10: 1738, 11: 2109, 12: 2521, 13: 2976, 14: 3474, 15: 4015, 16: 4602, 17: 5233, 18: 5910, 19: 6633, 20: 7402}
        }
        
        # 어센틱 심볼 데이터
        self.authentic_symbols = {
            'cernium': {2: 3650, 3: 9120, 4: 16070, 5: 24190, 6: 33150, 7: 42620, 8: 52290, 9: 61820, 10: 70900, 11: 79200},
            'arcus_island': {2: 4170, 3: 10480, 4: 18610, 5: 28220, 6: 39000, 7: 50610, 8: 62740, 9: 75070, 10: 87260, 11: 99000},
            'odium': {2: 4690, 3: 11850, 4: 21150, 5: 32250, 6: 44850, 7: 58600, 8: 73200, 9: 88320, 10: 103620, 11: 118800},
            'shangri_la': {2: 5220, 3: 13220, 4: 23680, 5: 36280, 6: 50700, 7: 66600, 8: 83660, 9: 101560, 10: 119980, 11: 138600},
            'arteria': {2: 5740, 3: 14590, 4: 26220, 5: 40320, 6: 56550, 7: 74590, 8: 94120, 9: 114810, 10: 136350, 11: 158400},
            'carcion': {2: 6260, 3: 15960, 4: 28760, 5: 44350, 6: 62400, 7: 82580, 8: 104580, 9: 128060, 10: 152710, 11: 178200},
            'tallahart': {2: 11360, 3: 29330, 4: 53580, 5: 83770, 6: 119600, 7: 160720, 8: 206830, 9: 257600, 10: 312690, 11: 371800}
        }
        
        # 레벨별 접근 가능 지역 매핑 - 딕셔너리 자료구조
        self.level_access = {
            200: ['vanishing_journey'],
            210: ['vanishing_journey', 'chu_chu_island'],
            220: ['vanishing_journey', 'chu_chu_island', 'lachelein'],
            225: ['vanishing_journey', 'chu_chu_island', 'lachelein', 'arcana'],
            230: ['vanishing_journey', 'chu_chu_island', 'lachelein', 'arcana', 'morass'],
            235: ['vanishing_journey', 'chu_chu_island', 'lachelein', 'arcana', 'morass', 'esfera'],
            260: ['cernium'],
            265: ['cernium', 'arcus_island'],
            270: ['cernium', 'arcus_island', 'odium'],
            275: ['cernium', 'arcus_island', 'odium', 'shangri_la'],
            280: ['cernium', 'arcus_island', 'odium', 'shangri_la', 'arteria'],
            285: ['cernium', 'arcus_island', 'odium', 'shangri_la', 'arteria', 'carcion'],
            290: ['cernium', 'arcus_island', 'odium', 'shangri_la', 'arteria', 'carcion', 'tallahart']
        }
    
    def setup_gui(self):
        """스크롤 가능한 전체 GUI 구성"""
        outer_frame = ttk.Frame(self.root)
        outer_frame.grid(row=0, column=0, sticky="nsew")
        self.root.rowconfigure(0, weight=1)
        self.root.columnconfigure(0, weight=1)

        canvas = tk.Canvas(outer_frame)
        canvas.grid(row=0, column=0, sticky="nsew")

        scrollbar = ttk.Scrollbar(outer_frame, orient="vertical", command=canvas.yview)
        scrollbar.grid(row=0, column=1, sticky="ns")

        outer_frame.rowconfigure(0, weight=1)
        outer_frame.columnconfigure(0, weight=1)

        scrollable_frame = ttk.Frame(canvas)
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        scrollable_frame.columnconfigure(0, weight=1)

        window = canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        def _on_canvas_resize(event):
            canvas.itemconfig(window, width=event.width)

        canvas.bind("<Configure>", _on_canvas_resize)

        # 메인 프레임
        main_frame = ttk.Frame(scrollable_frame, padding="10")
        main_frame.grid(row=0, column=0, sticky="nsew")
        main_frame.columnconfigure(1, weight=1)

        # API 키 입력
        ttk.Label(main_frame, text="API 키:").grid(row=0, column=0, sticky=tk.W, pady=2)
        ttk.Entry(main_frame, textvariable=self.api_key, width=50, show="*").grid(row=0, column=1, columnspan=2, sticky=(tk.W, tk.E), pady=2)

        # 캐릭터명 입력
        ttk.Label(main_frame, text="캐릭터명:").grid(row=1, column=0, sticky=tk.W, pady=2)
        ttk.Entry(main_frame, textvariable=self.character_name, width=30).grid(row=1, column=1, sticky=(tk.W, tk.E), pady=2)
        ttk.Button(main_frame, text="캐릭터 로드", command=self.load_character).grid(row=1, column=2, padx=(10, 0), pady=2)

        # 캐릭터 정보 출력
        info_frame = ttk.LabelFrame(main_frame, text="캐릭터 정보", padding="10")
        info_frame.grid(row=2, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=10)

        char_info_frame = ttk.Frame(info_frame)
        char_info_frame.pack(fill=tk.BOTH, expand=True)

        self.image_label = ttk.Label(char_info_frame)
        self.image_label.pack(side=tk.LEFT, padx=(0, 10))

        self.info_text = scrolledtext.ScrolledText(char_info_frame, height=8, width=60)
        self.info_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # 심볼 타입 선택
        symbol_frame = ttk.LabelFrame(main_frame, text="심볼 타입 선택", padding="10")
        symbol_frame.grid(row=3, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=10)

        ttk.Radiobutton(symbol_frame, text="아케인 심볼", variable=self.symbol_type, value="arcane").pack(side=tk.LEFT, padx=10)
        ttk.Radiobutton(symbol_frame, text="어센틱 심볼", variable=self.symbol_type, value="authentic").pack(side=tk.LEFT, padx=10)
        ttk.Button(symbol_frame, text="심볼 정보 로드", command=self.load_symbols).pack(side=tk.LEFT, padx=20)

        # 심볼 정보 표시
        self.symbol_text = scrolledtext.ScrolledText(main_frame, height=8, width=80)
        self.symbol_text.grid(row=4, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 10))

        # 목표 설정
        target_frame = ttk.LabelFrame(main_frame, text="목표 설정", padding="10")
        target_frame.grid(row=5, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=10)

        ttk.Label(target_frame, text="목표 포스:").pack(side=tk.LEFT)
        ttk.Entry(target_frame, textvariable=self.target_force, width=10).pack(side=tk.LEFT, padx=10)
        ttk.Button(target_frame, text="최적화 계산", command=self.calculate_optimization).pack(side=tk.LEFT, padx=20)

        # 최적화 결과 출력
        result_frame = ttk.LabelFrame(main_frame, text="최적화 결과", padding="10")
        result_frame.grid(row=6, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=10)

        self.result_text = scrolledtext.ScrolledText(result_frame, height=15, width=80)
        self.result_text.pack(fill=tk.BOTH, expand=True)

        # 진행 상황 프로그래스바
        self.progress = ttk.Progressbar(main_frame, mode='indeterminate')
        self.progress.grid(row=7, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=5)

    def load_character(self):
        """캐릭터 정보 로드"""
        if not self.api_key.get() or not self.character_name.get():
            messagebox.showerror("오류", "API 키와 캐릭터명을 입력해주세요.")
            return
        
        threading.Thread(target=self._load_character_thread).start()
    
    def _load_character_thread(self):
        """캐릭터 정보 로드 스레드"""
        try:
            self.progress.start()
            
            # OCID 조회
            ocid_url = f"https://open.api.nexon.com/maplestory/v1/id?character_name={self.character_name.get()}"
            headers = {"x-nxopen-api-key": self.api_key.get()}
            
            response = requests.get(ocid_url, headers=headers)
            if response.status_code != 200:
                raise Exception(f"API 호출 실패: {response.status_code} - {response.text}")
            
            ocid = response.json()["ocid"]
            
            # 어제 날짜로 캐릭터 정보 조회 (오늘 데이터는 아직 갱신되지 않을 수 있음)
            yesterday = (datetime.now() - timedelta(days=1)).strftime("%Y-%m-%d")
            
            # 기본 정보 조회
            basic_url = f"https://open.api.nexon.com/maplestory/v1/character/basic?ocid={ocid}&date={yesterday}"
            basic_response = requests.get(basic_url, headers=headers)
            basic_info = basic_response.json()
            
            self.character_info = basic_info
            
            # 캐릭터 이미지 조회
            try:
                image_url = basic_info.get('character_image')
                if image_url:
                    image_response = requests.get(image_url)
                    if image_response.status_code == 200:
                        image_data = Image.open(io.BytesIO(image_response.content))
                        # 이미지 크기 조정
                        image_data = image_data.resize((96, 96), Image.Resampling.LANCZOS)
                        self.character_image = ImageTk.PhotoImage(image_data)
                    else:
                        self.character_image = None
                else:
                    self.character_image = None
            except Exception as img_error:
                print(f"이미지 로드 오류: {img_error}")
                self.character_image = None
            
            # GUI 업데이트
            self.root.after(0, self._update_character_info)
            
        except Exception as e:
            self.root.after(0, lambda: messagebox.showerror("오류", f"캐릭터 로드 실패: {str(e)}"))
        finally:
            self.root.after(0, self.progress.stop)
    
    def _update_character_info(self):
        """캐릭터 정보 GUI 업데이트"""
        # 캐릭터 이미지 표시
        if hasattr(self, 'character_image') and self.character_image:
            self.image_label.configure(image=self.character_image)
        else:
            self.image_label.configure(text="이미지 없음", image="")
        
        # 캐릭터 정보 표시
        info = self.character_info
        text = f"""캐릭터명: {info.get('character_name', 'N/A')}
월드명: {info.get('world_name', 'N/A')}
클래스: {info.get('character_class', 'N/A')}
레벨: {info.get('character_level', 'N/A')}
길드명: {info.get('character_guild_name', 'N/A') or '길드 없음'}
전직: {info.get('character_class_level', 'N/A')}차 전직 완료
경험치: {info.get('character_exp_rate', 'N/A')}%"""
        
        self.info_text.delete(1.0, tk.END)
        self.info_text.insert(1.0, text)
    
    def load_symbols(self):
        """심볼 정보 로드"""
        if not self.character_info:
            messagebox.showerror("오류", "먼저 캐릭터를 로드해주세요.")
            return
        
        threading.Thread(target=self._load_symbols_thread).start()
    
    def _load_symbols_thread(self):
        """심볼 정보 로드 스레드"""
        try:
            self.progress.start()
            
            # OCID와 날짜 설정
            ocid_url = f"https://open.api.nexon.com/maplestory/v1/id?character_name={self.character_name.get()}"
            headers = {"x-nxopen-api-key": self.api_key.get()}
            response = requests.get(ocid_url, headers=headers)
            ocid = response.json()["ocid"]
            yesterday = (datetime.now() - timedelta(days=1)).strftime("%Y-%m-%d")
            
            # 심볼 정보 조회
            symbol_url = f"https://open.api.nexon.com/maplestory/v1/character/symbol-equipment?ocid={ocid}&date={yesterday}"
            symbol_response = requests.get(symbol_url, headers=headers)
            
            if symbol_response.status_code != 200:
                raise Exception(f"심볼 API 호출 실패: {symbol_response.status_code} - {symbol_response.text}")
            
            symbol_data = symbol_response.json()
            # print(f"심볼 API 응답: {json.dumps(symbol_data, indent=2, ensure_ascii=False)}")  # 디버깅용
            
            self.symbol_info = symbol_data
            
            # GUI 업데이트
            self.root.after(0, self._update_symbol_info)
            
        except Exception as e:
            self.root.after(0, lambda: messagebox.showerror("오류", f"심볼 로드 실패: {str(e)}"))
        finally:
            self.root.after(0, self.progress.stop)
    
    def _update_symbol_info(self):
        """심볼 정보 GUI 업데이트"""
        current_text = self.info_text.get(1.0, tk.END)
        
        # 아케인 심볼 이름 매핑
        arcane_symbol_names = {
            '소멸의 여로': 'vanishing_journey',
            'VanishingJourney': 'vanishing_journey',
            '츄츄 아일랜드': 'chu_chu_island', 
            'ChuChuIsland': 'chu_chu_island',
            '레헬른': 'lachelein',
            'Lachelein': 'lachelein',
            '아르카나': 'arcana',
            'Arcana': 'arcana',
            '모라스': 'morass',
            'Morass': 'morass',
            '에스페라': 'esfera',
            'Esfera': 'esfera'
        }
        
        # 어센틱 심볼 이름 매핑
        authentic_symbol_names = {
            '세르니움': 'cernium',
            'Cernium': 'cernium',
            '아르크스': 'arcus_island',
            'Arcus': 'arcus_island',
            '오디움': 'odium',
            'Odium': 'odium',
            '도원경': 'shangri_la',
            'Shangri-La': 'shangri_la',
            '아르테리아': 'arteria',
            'Arteria': 'arteria',
            '카르시온': 'carcion',
            'Carcion': 'carcion',
            '탈라하트': 'tallahart',
            'Tallahart': 'tallahart'
        }
        
        symbol_text = ""
        
        if self.symbol_type.get() == "arcane":
            symbol_text = "=== 아케인 심볼 정보 ===\n"
            if self.symbol_info and 'symbol' in self.symbol_info:
                for symbol in self.symbol_info['symbol']:
                    symbol_name = symbol.get('symbol_name', '')
                    symbol_level = symbol.get('symbol_level', 0)
                    
                    # 아케인 심볼인지 확인
                    if symbol_name in arcane_symbol_names or any(key in symbol_name for key in arcane_symbol_names.keys()):
                        force = 30 + (symbol_level - 1) * 10  # 아케인 심볼 포스 계산
                        symbol_text += f"{symbol_name}: Lv.{symbol_level} (포스 +{force})\n"
            else:
                symbol_text += "심볼 정보를 찾을 수 없습니다.\n"
        else:
            symbol_text = "=== 어센틱 심볼 정보 ===\n"
            if self.symbol_info and 'symbol' in self.symbol_info:
                for symbol in self.symbol_info['symbol']:
                    symbol_name = symbol.get('symbol_name', '')
                    symbol_level = symbol.get('symbol_level', 0)
                    
                    # 어센틱 심볼인지 확인
                    if symbol_name in authentic_symbol_names or any(key in symbol_name for key in authentic_symbol_names.keys()):
                        force = 10 + (symbol_level - 1) * 10  # 어센틱 심볼 포스 계산
                        symbol_text += f"{symbol_name}: Lv.{symbol_level} (포스 +{force})\n"
            else:
                symbol_text += "심볼 정보를 찾을 수 없습니다.\n"
        
        
        self.symbol_text.delete(1.0, tk.END)
        self.symbol_text.insert(1.0, symbol_text)
    
    def calculate_optimization(self):
        """브루트포스를 이용한 최적화 계산"""
        if not self.symbol_info or not self.target_force.get():
            messagebox.showerror("오류", "심볼 정보를 로드하고 목표 포스를 입력해주세요.")
            return
        
        threading.Thread(target=self._calculate_optimization_thread).start()
    
    def _calculate_optimization_thread(self):
        """최적화 계산 스레드 - 브루트포스 알고리즘 사용"""
        try:
            self.progress.start()
            
            # 현재 심볼 레벨과 포스 계산
            current_symbols = {}  # 딕셔너리 자료구조
            current_force = 0
            character_level = self.character_info.get('character_level', 200)
            
            # 접근 가능한 지역 확인
            accessible_areas = self.get_accessible_areas(character_level)
            
            if self.symbol_type.get() == "arcane":
                symbol_data = self.arcane_symbols
                base_force = 30  # 1레벨 기본 포스
                force_per_level = 10
                
                for symbol in self.symbol_info.get('symbol', []):
                    symbol_name = symbol['symbol_name']
                    if symbol_name in ['소멸의 여로', '츄츄 아일랜드', '레헬른', '아르카나', '모라스', '에스페라']:
                        area_key = self.get_area_key(symbol_name)
                        if area_key in accessible_areas:
                            level = symbol['symbol_level']
                            current_symbols[area_key] = level
                            current_force += base_force + (level - 1) * force_per_level
            else:
                symbol_data = self.authentic_symbols
                base_force = 10  # 1레벨 기본 포스
                force_per_level = 10
                
                for symbol in self.symbol_info.get('symbol', []):
                    symbol_name = symbol['symbol_name']
                    if symbol_name in ['세르니움', '아르크스', '오디움', '도원경', '아르테리아', '카르시온', '탈라하트']:
                        area_key = self.get_area_key(symbol_name)
                        if area_key in accessible_areas:
                            level = symbol['symbol_level']
                            current_symbols[area_key] = level
                            current_force += base_force + (level - 1) * force_per_level
            
            # 브루트포스로 최적 조합 찾기
            target = self.target_force.get()
            if current_force >= target:
                result = "이미 목표 포스에 도달했습니다!"
                self.root.after(0, lambda: self._update_result(result))
                return
            
            needed_force = target - current_force
            
            # 동적 프로그래밍을 위한 메모이제이션 - 딕셔너리 자료구구
            memo = {}
            
            # 브루트포스 + 정렬 알고리즘으로 최적해 찾기
            best_solutions = self.brute_force_optimization(
                current_symbols, accessible_areas, needed_force, 
                symbol_data, base_force, force_per_level, memo
            )
            
            # 결과 정렬 - 정렬 알고리즘 사용 (비용 기준 오름차순)
            best_solutions.sort(key=lambda x: x[1])
            
            # 결과 출력
            result = self.format_results(best_solutions[:10], current_force, target)
            self.root.after(0, lambda: self._update_result(result))
            
        except Exception as e:
            self.root.after(0, lambda: messagebox.showerror("오류", f"계산 실패: {str(e)}"))
        finally:
            self.root.after(0, self.progress.stop)
    
    def brute_force_optimization(self, current_symbols, accessible_areas, needed_force, 
                               symbol_data, base_force, force_per_level, memo):
        """브루트포스 알고리즘으로 최적 조합 찾기"""
        solutions = []  # 리스트 자료구조
        
        # 각 심볼의 현재 레벨과 최대 레벨 설정
        max_level = 20 if self.symbol_type.get() == "arcane" else 11
        
        # 모든 가능한 조합 생성 (브루트포스)
        level_ranges = []
        for area in accessible_areas:
            current_level = current_symbols.get(area, 1)
            level_ranges.append(range(current_level, max_level + 1))
        
        # 조합 생성 및 계산
        for combination in product(*level_ranges):
            total_cost = 0
            total_added_force = 0
            upgrade_plan = {}
            
            for i, area in enumerate(accessible_areas):
                current_level = current_symbols.get(area, 1)
                target_level = combination[i]
                
                if target_level > current_level:
                    # 레벨업 비용 계산
                    cost = self.calculate_upgrade_cost(area, current_level, target_level, symbol_data)
                    total_cost += cost
                    
                    # 추가 포스 계산
                    added_force = (target_level - current_level) * force_per_level
                    total_added_force += added_force
                    
                    upgrade_plan[area] = (current_level, target_level, cost)
            
            # 목표 포스에 도달하는 조합만 저장
            if total_added_force >= needed_force:
                solutions.append((upgrade_plan, total_cost, total_added_force))
        
        return solutions
    
    def calculate_upgrade_cost(self, area, current_level, target_level, symbol_data):
        """심볼 업그레이드 비용 계산 - 동적 프로그래밍 사용"""
        total_cost = 0
        for level in range(current_level + 1, target_level + 1):
            if level in symbol_data[area]:
                total_cost += symbol_data[area][level]
        return total_cost
    
    def get_accessible_areas(self, character_level):
        """캐릭터 레벨에 따른 접근 가능 지역 반환"""
        accessible = []
        
        if self.symbol_type.get() == "arcane":
            for level_req in [200, 210, 220, 225, 230, 235]:
                if character_level >= level_req:
                    accessible.extend(self.level_access[level_req])
        else:
            for level_req in [260, 265, 270, 275, 280, 285, 290]:
                if character_level >= level_req:
                    accessible.extend(self.level_access[level_req])
        
        return list(set(accessible))  # 중복 제거
    
    def get_area_key(self, symbol_name):
        """심볼명을 지역 키로 변환"""
        name_mapping = {
            '소멸의 여로': 'vanishing_journey',
            '츄츄 아일랜드': 'chu_chu_island',
            '레헬른': 'lachelein',
            '아르카나': 'arcana',
            '모라스': 'morass',
            '에스페라': 'esfera',
            '세르니움': 'cernium',
            '아르크스': 'arcus_island',
            '오디움': 'odium',
            '도원경': 'shangri_la',
            '아르테리아': 'arteria',
            '카르시온': 'carcion',
            '탈라하트': 'tallahart'
        }
        return name_mapping.get(symbol_name, symbol_name)
    
    def format_results(self, solutions, current_force, target_force):
        """결과 포맷팅"""
        if not solutions:
            return "목표 포스에 도달할 수 있는 조합이 없습니다."
        
        result = f"현재 포스: {current_force}\n"
        result += f"목표 포스: {target_force}\n"
        result += f"필요 포스: {target_force - current_force}\n\n"
        result += "=== 최적화 결과 (비용 기준 오름차순) ===\n\n"
        
        area_names = {
            'vanishing_journey': '소멸의 여로',
            'chu_chu_island': '츄츄 아일랜드',
            'lachelein': '레헬른',
            'arcana': '아르카나',
            'morass': '모라스',
            'esfera': '에스페라',
            'cernium': '세르니움',
            'arcus_island': '아르크스',
            'odium': '오디움',
            'shangri_la': '도원경',
            'arteria': '아르테리아',
            'carcion': '카르시온',
            'tallahart': '탈라하트'
        }
        
        for i, (upgrade_plan, total_cost, added_force) in enumerate(solutions[:5], 1):
            result += f"[방법 {i}] 총 비용: {total_cost:,} 메소, 추가 포스: +{added_force}\n"
            
            for area, (current, target, cost) in upgrade_plan.items():
                area_name = area_names.get(area, area)
                result += f"  {area_name}: Lv.{current} → Lv.{target} (비용: {cost:,} 메소)\n"
            
            result += "\n"
        
        return result
    
    def _update_result(self, result):
        """결과 텍스트 업데이트"""
        self.result_text.delete(1.0, tk.END)
        self.result_text.insert(1.0, result)

def main():
    root = tk.Tk()
    app = MapleSymbolOptimizer(root)
    root.mainloop()

if __name__ == "__main__":
    main()